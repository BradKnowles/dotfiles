{{ template "Header.tmpl" . }}
Function Edit-AwsConfig() {
	[CmdletBinding()]
	[Alias("eaws")]
	Param()

  code $Env:USERPROFILE\.aws
}

Function Set-AwsProfile() {
	[CmdletBinding()]
	[Alias("sap")]
	Param(
		[Parameter(Mandatory=$true)]
		$ProfileName
	)

	$PreviousProfile = $Env:AWS_PROFILE ?? "empty"

	# Set profile for CLI
	$Env:AWS_PROFILE = $ProfileName

	# If profile doesn't exist in .aws directory, create a placeholder
	if ($null -eq $(Read-AwsCredentialFile)[$ProfileName]) {
		Add-AwsProfile -ProfileName $ProfileName
	}

	Write-Host "$(frt('Updated')) $(fvr('AWS_PROFILE')) $(frt('from')) $(fvl($PreviousProfile)) $(frt('to')) $(fvl($ProfileName))"

	# Set profile for PowerShell Tools
	Set-AWSCredential -ProfileName $ProfileName -Scope Global

	#Set region for CLI and PowerShell Tools
	Set-AwsRegion -Region $(Get-AwsRegionLocal)
}

Function Set-AwsRegion() {
	[CmdletBinding()]
	[Alias("sar")]
	Param(
		[Parameter(Mandatory=$true)]
		[ArgumentCompletions("af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ap-southeast-5", "ap-southeast-7", "ca-central-1", "ca-west-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "mx-central-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2")]
		[ValidateSet("af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ap-southeast-5", "ap-southeast-7", "ca-central-1", "ca-west-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "mx-central-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2", IgnoreCase = $true)]
		$Region
	)

	$PreviousRegion = $Env:AWS_REGION ?? "empty"

	# Set region for CLI
	$Env:AWS_REGION = $Region

	# Set region for PowerShell Tools
	Set-DefaultAWSRegion -Region $Region -Scope Global

	Write-Host "$(frt('Updated')) $(fvr('AWS_REGION')) $(frt('from')) $(fvl($PreviousRegion)) $(frt('to')) $(fvl($Region))"
}

Function Clear-AwsProfile() {
	[CmdletBinding()]
	[Alias("cap")]
	Param()

	$evs = Get-ChildItem -Path "Env:\AWS_*"
	$evs | ForEach-Object {
		Write-Host "$(fvr($_.Name)) $(frt('cleared'))"
	}

	# Clear CLI properties
	Remove-Item -Path Env:AWS_*

	# Clear PowerShell Tools properties
	Clear-AWSDefaultConfiguration -SkipProfileStore -Scope Global
}

Function Connect-AwsAccount() {
	[CmdletBinding()]
	[Alias("ccaws")]

	$profileName = $Env:AWS_PROFILE
	if ([String]::IsNullOrWhiteSpace($profileName)) {
		Write-Error "AWS_PROFILE is empty, use Set-AwsProfile -Profile PROFILE_NAME to activate a profile."
		Return
	}

	$rawCredentials = $null
	$validCredentials = $false
	$keyMapping = @{
		AccessKeyId = "aws_access_key_id"
		SecretAccessKey = "aws_secret_access_key"
		SessionToken = "aws_session_token"
		aws_access_key_id = "aws_access_key_id"
		aws_secret_access_key = "aws_secret_access_key"
		aws_session_token = "aws_session_token"
		AWS_EXPIRATION = "x_security_token_expires"
		Expiration = "x_security_token_expires"
		x_security_token_expires = "x_security_token_expires"
	}

	$credentialProcess = $null;$source = $null

	# 1. Check for 'credential_process'
	$cp = aws configure get credential_process
	if ($null -ne $cp) {
			$credentialProcess = $cp
			$source = 'credential_process'
	}

	# 2. If not found, check for 'ps_credential_process'
	if (-not $credentialProcess) {
			$cp = aws configure get ps_credential_process
			if ($null -ne $cp) {
					$credentialProcess = $cp
					$source = 'ps_credential_process'
			}
	}

	# 3. If still not found, fallback to clipboard
	if (-not $credentialProcess) {
			$source = 'clipboard'
			$rawCredentials = Get-Clipboard -Raw
	} else {
			$rawCredentials = Invoke-Expression $credentialProcess
	}

	# Announce which source was used (only once)
	Write-Host "$(frt('Using')) $(fvr($source))"
	Write-Debug "Clipboard `$rawCredentials = $rawCredentials"

	# Look for any of the mapped keys in the credentials to determinate validity
	foreach($key in $keyMapping.Keys) {
		if ($rawCredentials -like "*$key*") {
			$validCredentials = $true
			break
		}
	}
	Write-Debug "`$validCredentials = $validCredentials"
	if ($validCredentials -eq $false) {
		Write-Error "Cannot parse contents into AWS credentials."
		Return
	}

	$parsedCredentials = [ordered]@{
		aws_access_key_id = $null
		aws_secret_access_key = $null
		aws_session_token = $null
		x_security_token_expires = $null
	}

	# Determine if credentils are JSON or (most likely) environment variables
	if ($rawCredentials | Test-Json -ErrorAction SilentlyContinue) {
		# If JSON, map raw credentials into parsed ones
		Write-Debug "JSON credentials"
		$jsonCredentials = $rawCredentials | ConvertFrom-Json
		foreach($property in $jsonCredentials.PSObject.Properties) {
			if ($keyMapping.ContainsKey($property.Name)) {
				$credentialKey = $keyMapping[$property.Name]
				$parsedCredentials.$credentialKey = $property.Value
			}
		}
	} else {
		# If environment variables, strip the commands, leaving the values
		# Then map the credentials into parsed ones
		Write-Debug "String credentials"
		$rawCredentials = $rawCredentials.Replace('set ', '')
		$rawCredentials = $rawCredentials.Replace('$Env:', '')
		$rawCredentials = $rawCredentials.Replace('export ', '')
		$stringCredentials = -split $rawCredentials
		$stringCredentials | ForEach-Object {
			if ($_ -notlike '') {
					$values = $_.Split('=').Trim('"')
					if ($keyMapping.ContainsKey($values[0])) {
						Write-Debug "keyMapping found for $($values[0])"
						$credentialKey = $keyMapping[$values[0]]
						$parsedCredentials.$credentialKey = $values[1]
					}
			}
		}
	}

	# Sometimes credential providers will supply some kind of session expiration
	# indicator. If not specified, prompt the user for the known default
	# expiration and store in `default_role_duration` in AWS config file.
	# If the expiration is specified, use the value provided.
	if ($null -eq $parsedCredentials.x_security_token_expires) {
		Write-Debug "No role duration detected"
		[Int32]$defaultRoleDuration = aws configure get default_role_duration
		Write-Debug "`$defaultRoleDuration = $defaultRoleDuration"

		if ($defaultRoleDuration -eq 0) {
			[Int32]$promptedRoleDuration = Read-Host -Prompt "Please enter the default role duration, in hours"
			aws configure set default_role_duration $promptedRoleDuration
			[Int32]$defaultRoleDuration = $promptedRoleDuration
			Write-Debug "`$defaultRoleDuration = $defaultRoleDuration"
		}
		$parsedCredentials.x_security_token_expires = $(Get-Date).AddHours($defaultRoleDuration).ToString("O")
	}

	# Write parsed credentials to file
	foreach($credential in $parsedCredentials.GetEnumerator()) {
		if ($null -eq $credential.Value) {
			break
		}

		Write-Debug "aws configure set $($credential.Name) $($credential.Value) --profile $profileName"
		Write-Host "$(frt('Setting')) $(fvr($credential.Name))$(frt('...'))" -NoNewline

		switch ($credential.Name) {
			"x_security_token_expires" {
				# This token has to be written in .aws/credentials file.
				# aws configure command writes non-standard values to the .aws/config file.
				# Manually load the .aws/credentials file and store the token properly
				$expirationDate = [System.DateTimeOffset]::Parse($credential.Value)
				$credentialsFile=Read-AwsCredentialFile
				$credentialsFile[$profileName].Remove('x_security_token_expires')
				$credentialsFile[$profileName].Add('x_security_token_expires', ($expirationDate).ToString("O"))
				Write-AwsCredentialFile -InputObject $credentialsFile
			}
			default { aws configure set $credential.Name $credential.Value }
		}
		Write-Host "$(fs('done.'))"
	}
}

Function Get-AwsCredentialFile() {
	"$Env:USERPROFILE\.aws\credentials"
}

Function Read-AwsCredentialFile() {
	Import-Ini -Path $(Get-AwsCredentialFile)
}

Function Write-AwsCredentialFile {
	Param(
		[Parameter(Mandatory=$true)]
		$InputObject
	)
	Export-IniFile -InputObject $InputObject -FilePath $(Get-AwsCredentialFile) -Force
}

Function Add-AwsProfile() {
	Param(
		[Parameter(Mandatory=$true)]
		$ProfileName
	)

	aws configure set aws_access_key_id "PLACEHOLDER" --profile $ProfileName
	aws configure set aws_secret_access_key "PLACEHOLDER" --profile $ProfileName
	aws configure set region "us-east-2" --profile $ProfileName
	aws configure set output "yaml" --profile $ProfileName
}

Function Get-AwsRegionLocal() {
	$Env:AWS_REGION ?? $Env:AWS_DEFAULT_REGION ?? $(aws configure get region)
}

Function Get-AwsEc2Instances {
	[Alias("gec2")]
	Param(
		[ValidateSet("Pending", "Running", "ShuttingDown", "Terminated", "Stopping", "Stopped", "NotRunning", IgnoreCase = $true)]
		[string]$State
	)

	$filters = @{'Name' = 'instance-state-name'}
	If($PSBoundParameters.ContainsKey('State')) {
		if($State -eq 'NotRunning') {
			$filters.Add('Values', @('pending','shutting-down','stopping','stopped'))
		} else {
			$filters.Add('Values', @($State.ToLower()))
		}
	} else {
		$filters.Clear()
	}

	$instances = $(Get-Ec2Instance -Filter $filters).Instances
		| Select-Object 'InstanceId',
				@{Name='Name';Expression={$_.Tags[$_.Tags.Key.IndexOf('Name')].Value}},
				@{Name='PrivateIP';Expression={$_.PrivateIpAddress}},
				@{Name='State';Expression={$_.State.Name}}

	$statuses=@{}
	Get-EC2InstanceStatus -Filter $filters | ForEach-Object {
			$statuses.Add($_.InstanceId, @{
				AttachedEbsStatus = $_.AttachedEbsStatus.Details.Status;
				Status = $_.Status.Details.Status;
				SystemStatus = $_.SystemStatus.Details.Status
			}
		)
	}

	foreach($instance in $instances) {
		$instance | Add-Member -MemberType NoteProperty -Name 'AttachedEbsStatus' -Value ($statuses[$instance.InstanceId].AttachedEbsStatus ?? "N/A")
		$instance | Add-Member -MemberType NoteProperty -Name 'Status' -Value ($statuses[$instance.InstanceId].Status ?? "N/A")
		$instance | Add-Member -MemberType NoteProperty -Name 'SystemStatus' -Value ($statuses[$instance.InstanceId].SystemStatus ?? "N/A")
	}
	$instances | Format-Table -AutoSize
}

Function Set-AwsEc2CacheFile {
	$cacheFile = "$Env:USERPROFILE\.aws\pscache.yaml"
	Write-Debug "$(fvr('$cacheFile')) = $(fvl($cacheFile))"

	if (-not (Test-Path -Path $cacheFile -PathType Leaf)) {
		$cache = [ordered]@{
			ec2 = [ordered]@{
				settings = [ordered]@{
					'cache-timeout' = "01:00:00"
					'last-updated' = $(Get-Date).AddHours(-2)
					'starting-local-port' = 2000
				}
				instances = @()
			}
		}

		$cache | ConvertTo-Yaml -Depth 3 | Out-File -FilePath $cacheFile
	}

	$cacheFile
}

Function Update-AwsEc2Cache {
	[CmdletBinding()]
	param (
			[switch]$Force
	)

	$debug = $PSCmdlet.MyInvocation.BoundParameters["Debug"].IsPresent

	$cacheFile = Set-AwsEc2CacheFile
	Write-Debug "$(fvr('$cacheFile')) = $(fvl($cacheFile))"

	$cache = Get-Content $cacheFile -Raw | ConvertFrom-Yaml
	$cacheUpdateDifference = New-TimeSpan -Start ([DateTime]($cache.ec2.settings.'last-updated' ?? (Get-Date))) -End (Get-Date)

	Write-Debug "$(fvr('$cacheLastUpdated')) = $(fvl([DateTime]$cache.ec2.settings.'last-updated'))"
	Write-Debug "$(fvr('$cacheUpdateDifference')) = $(fvl($cacheUpdateDifference))"

	if ((-not $Force) -and ($cacheUpdateDifference -lt [TimeSpan]$cache.ec2.settings.'cache-timeout')) {
			Write-Host "$(frt('Cache timeout of')) $(fvl($cache.ec2.settings.'cache-timeout')) $(frt('not expired, skipping update.'))"
			return
	}

	Write-Host "$(frt("Updating EC2 Cache..."))"

	$filters = @{'Name' = 'instance-state-name';
			'Values'= @('pending', 'running', 'shutting-down', 'stopping', 'stopped')}

	$instances = $(Get-Ec2Instance -Filter $filters).Instances
		| Select-Object @{Name='name';Expression={$_.Tags[$_.Tags.Key.IndexOf('Name')].Value}},
				@{Name='instance-id'; Expression={$_.InstanceId}},
				@{Name='key-name';Expression={$_.KeyName}},
				@{Name='private-ip'; Expression={$_.PrivateIpAddress}},
				@{Name='public-ip'; Expression={$_.PublicIpAddress}},
				@{Name='protocol';Expression={($_.Platform -ilike '*Windows*') ? ('rdp') : ('ssh') }}

	if ($debug) {
			Write-Host
			foreach ($i in $cache.ec2.instances) {
					Write-Debug "$(frt('Removing')) $(fvl("$($i.name) - $($i.'instance-id')"))"
			}
	}

	$startingPort = $cache.ec2.settings.'starting-local-port'
	$result = [System.Collections.ArrayList]::new()
	$instances | ForEach-Object {
			$_ | Add-Member -MemberType NoteProperty -Name 'local-port' -Value ([String]$startingPort)
			[void]$result.Add($_)
			$startingPort++
	}

	$cache.ec2.instances = $result
	$cache.ec2.settings.'last-updated' = Get-Date
	$cache | ConvertTo-Yaml -Depth 3 | Out-File -FilePath $cacheFile

	$result | Format-Table
	Write-Host "$(fs('done.'))"
}

Function Get-AwsCache {
	$cacheFile = Set-AwsEc2CacheFile
	Update-AwsEc2Cache
	Get-Content $cacheFile -Raw | ConvertFrom-Yaml
}

function Connect-AwsSsmPort {
	[Alias('cssmp')]
	Param(
		[Parameter()]
		$InstanceName,
		[Switch]$WithPassword
	)

	$cache = Get-AwsCache
	$instance = $cache.ec2.instances | Where-Object {$_.'name' -eq $InstanceName}
	$portNumber = ($instance.'protocol' -eq 'rdp') ? '3389' : '22'

	$sessionParams = @{
		DocumentName = "AWS-StartPortForwardingSession"
		Target = $instance.'instance-id'
		Parameter = @{
			portNumber = $portNumber
			localPortNumber = $instance.'local-port'
		}
	}

	if ($WithPassword) {
		Get-AwsEc2Password-InstanceId $instance.'instance-id' -KeyName $instance.'key-name'
	}

	Write-Host "$(frt('Connecting to')) $(fvl("$($instance.'name') - $($instance.'instance-id')")) $(fvr('LocalPort')) $(fvl($($instance.'local-port'))) $(fvr('RemotePort')) $(fvl($portNumber))"
	Start-SSMSession @sessionParams
}

Function Get-AwsEc2Password {
	[CmdletBinding()]
	[Alias("gec2p")]
	Param(
		[Parameter(Mandatory=$true)]
		$InstanceId,
		[Parameter(Mandatory=$true)]
		$KeyName
	)

	$params = @{
		InstanceId = $InstanceId
		PemFile = "$Env:USERPROFILE\.aws\ec2-keys\$KeyName.pem"
	}

	if (Test-Path -Path $params.PemFile) {
		$password = Get-EC2PasswordData @params

		Set-Clipboard $password
		Write-Host "$(fvl('Administrator')) $(frt('password copied to clipboard'))"
	} else {
		Write-Error "Password not retrieved. Unable to find $($(fvl($params.PemFile)))"
	}
}

Function Start-AwsEc2Instance {
	[CmdletBinding()]
	[Alias("saec2")]
	Param(
		[Switch]$All
	)

	# Get stopped instances
	$filters = @{
		'Name' = 'instance-state-name'
		'Values'= @('stopped')
	}

	$stoppedInstances = $(Get-Ec2Instance -Filter $filters).Instances
		| Select-Object 'InstanceId',
				@{Name='Name';Expression={$_.Tags[$_.Tags.Key.IndexOf('Name')].Value}}

	if (($stoppedInstances | Measure-Object).Count -eq 0) {
		Write-Host "$(frt('No stopped instances to be started.'))"
		return
	}

	## Determine which instances to start
	# If All flag is passed start all instances
	if ($All) {
		$instancesToStart = ($stoppedInstances | Select-Object -ExpandProperty InstanceId)
	} else {
	# Use fzf to multiselect instances for starting
		$fzfOptions = @('--height', '~100%',
			'--layout','reverse',
			'--ansi',
			'--border', 'rounded',
			'--multi', '--accept-nth=1',
			'--header', "Select Instance(s) to Start`nTAB: Select Instance; CTRL-A:Select all; CTRL-D:Deselect all; ESC: Abort",
			'--header-border','rounded'
			'--bind', 'ctrl-a:select-all,ctrl-d:deselect-all'
		)

		$instancesToStart = $stoppedInstances | ForEach-Object {"$($_.InstanceId)`t$($_.Name)"} | fzf $fzfOptions
		if (($instancesToStart | Measure-Object).Count -eq 0) {
			Write-Host "$(frt('No instances selected, nothing to start.'))"
			return
		}
	}

	Start-EC2Instance -InstanceId $instancesToStart
		| Select-Object @{Name='CurrentState';Expression={$_.CurrentState.Name}},
				InstanceId, @{Name='PreviousState';Expression={$_.PreviousState.Name}}
}

Function Stop-AwsEc2Instance {
	[CmdletBinding()]
	[Alias("spec2")]
	Param(
		[Switch]$All
	)

	# Get running instances
	$filters = @{
		'Name' = 'instance-state-name'
		'Values'= @('running')
	}

	$runningInstances = $(Get-Ec2Instance -Filter $filters).Instances
		| Select-Object 'InstanceId', @{Name='Name';Expression={$_.Tags[$_.Tags.Key.IndexOf('Name')].Value}}

	if (($runningInstances | Measure-Object).Count -eq 0) {
		Write-Host "$(frt('No running instances to be stopped.'))"
		return
	}

	## Determine which instances to stop
	# If All flag is passed stop all instances
	if ($All) {
		$instancesToStop = ($runningInstances | Select-Object -ExpandProperty InstanceId)
	} else {
	# Use fzf to multiselect instances for stopping
		$fzfOptions = @('--height', '~100%',
			'--layout',	'reverse',
			'--ansi',
			'--border', 'rounded',
			'--multi', '--accept-nth=1',
			'--header', "Select Instance(s) to Stop`nTAB: Select Instance; CTRL-A:Select all; CTRL-D:Deselect all; ESC: Abort",
			'--header-border','rounded'
			'--bind', 'ctrl-a:select-all,ctrl-d:deselect-all'
		)

		$instancesToStop = $runningInstances | ForEach-Object {"$($_.InstanceId)`t$($_.Name)"} | fzf $fzfOptions
		if (($instancesToStop | Measure-Object).Count -eq 0) {
			Write-Host "$(frt('No instances selected, nothing to stop.'))"
			return
		}
	}

	Stop-EC2Instance -InstanceId $instancesToStop
		| Select-Object @{Name='CurrentState';Expression={$_.CurrentState.Name}},
				InstanceId, @{Name='PreviousState';Expression={$_.PreviousState.Name}}
}
